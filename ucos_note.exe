/**
  ******************************************************************************
  * @file    ucos_note
  * @author  杜公子寒枫
  * @version V1.0
  * @date    2017.05.17
  * @brief   ucos V2.86
  ******************************************************************************
  * @attention
  * 
  * V1.1------------
  * 修改描述: 增加ucos启动流程分析
  * 修改作者: 杜公子寒枫
  * 当前版本: V1.1
  * 修改日期: 2017.05.18
  * 
  ******************************************************************************
  */

/*----------------------------------------------------------------------------
    移植要点
 *----------------------------------------------------------------------------*/
 
1. 屏蔽钩子函数(将OS_APP_HOOKS_EN设为0)或者是自行将其实现
2. 在滴答中断中调用OS_CPU_SysTickHandler(此函数自带中断互斥操作)或者是OSTimeTick(需要在调用此函数的前后自行调用开关中断操作)
3. 将启动文件中的PendSV_Handler改成OS_CPU_PendSVHandler,切忌二次调用(例如在自带的PendSV_Handler中再调用OS_CPU_PendSVHandler),因为第二次调用时SP和一些寄存器的内容已经被改变,导致系统调度失败,从而卡死在B OSStartHang 之中


/*----------------------------------------------------------------------------
    任务管理
 *----------------------------------------------------------------------------*/

创建任务:
1. 定义任务优先级          #define TASK_PRIO     (25) 
2. 定义任务栈栈长          #define TASK_STK_LEN  (64) 
3. 定义任务栈数组          OS_STK task_stk[TASK_STK_LEN] = {0}; 
4. 实现ucos任务调度函数    void ucos_task(void *p_arg);
5. 创建任务  OSTaskCreate(ucos_task,(void *)0,&task_stk[TASK_STK_LEN-1],TASK_PRIO);

注: 
(1) 任务优先级分为0~62,数值越小,优先级越高; 
(2) 任务栈是用于存储当前栈区的数据以保护现场.如果任务栈要保存float数据,则必须 
    8个字节对齐(用__align(8)指定对齐); 
(3) OSTaskCreate的第三个入参ptos,若栈是下生长则入参其任务栈的末尾地址;如果是
    上生长则入参其任务栈的首地址.其栈的生长方向是由OS_STK_GROWTH的值来选择,
    而此值的取值取决于CPU的特性.

挂起任务:
OSTaskSuspend(INT8U prio)
INT8U prio: 要挂起的任务的优先级,如果要挂起自身,调用宏OS_PRIO_SELF

恢复任务:
OSTaskResume(INT8U prio)
INT8U prio: 要解挂的任务的优先级


/*----------------------------------------------------------------------------
    互斥条件
 *----------------------------------------------------------------------------*/
 
当访问公共资源的时候,应避免任务的竞争以及对数据的破坏.
一般的方法有:

1. 开关中断(临界区)
OS_ENTER_CRITICAL();
OS_EXIT_CRITICAL();

2. 上锁(禁止任务切换)
OSSchedLock();
OSSchedUnlock();

3. 信号量
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr);
INT8U OSSemPost (OS_EVENT *pevent);


开关中断:
关中断的时间不能过长,多用于处理内部变量以及数据结构等快速的操作.
值得注意的是,使用开关中断的操作,需要定义变量OS_CPU_SR cpu_sr.

上锁:
上锁会禁止了任务的切换,但是不关闭中断,要求当前的任务不与中断共享变量或数据结构.

信号量用于：
(1) 控制共享资源的使用权(满足互斥条件)
(2) 标志某事件的发生
(3) 使两个任务的行为同步
值得注意的话,请求和释放信号量需要一定的时间,在处理简单的共享变量时并不建议这种方式(开关中断效率更高).
信号量适用于处理时间比较长的共享资源,例如串口打印,I2C传输,不带DSP的浮点数运算等.
在等待信号量时,任务处于挂起状态.


/*----------------------------------------------------------------------------
    任务间的通讯
 *----------------------------------------------------------------------------*/

1. 消息邮箱
具有信号传递的功能,可以把一个任务里面的局部变量传递给另一个任务使用

  1.1 创建邮箱
  OS_EVENT  *OSMboxCreate (void *pmsg);
  void *pmsg: 创建时要不要给信息给邮箱,不给则写(void *)0
  OS_EVENT *: 事件块地址(邮箱地址)
  
  1.2 删除邮箱
  OS_EVENT  *OSMboxDel (OS_EVENT *pevent, INT8U opt, INT8U *perr);
  
  
  1.3 发送邮箱
  INT8U  OSMboxPost (OS_EVENT *pevent, void *pmsg);
  OS_EVENT *pevent: 邮箱地址
  void *pmsg      : 要发送的消息的地址
  
  1.4 接收邮箱(阻塞)
  void  *OSMboxPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr);
  OS_EVENT *pevent: 邮箱地址
  INT16U timeout  : 超时时间
  INT8U *perr     : 错误码
  void  *         : 接收到的消息的地址
  
  1.5 接收邮箱(非阻塞)
  void  *OSMboxAccept (OS_EVENT *pevent);
  OS_EVENT *pevent: 邮箱地址
  void  *         : 接收到的消息的地址
  
  
2. 消息队列
实际上是邮箱的阵列,以解决单个邮箱只能传输单个数据的问题.

  2.1 创建队列
  OS_EVENT *OSQCreate( void **start, INT8U size);
  void **start: 存放消息地址的地址(可以考虑成一个指针数组 void * msg[size]的地址)
  INT8U size  : 队列存放消息的条数
  OS_EVENT *  : 事件块地址(队列地址)
  
  2.2 向队列发送信息
  INT8U OSQPost(OS_EVENT *pevent, void *msg);
  
  2.3 读取队列信息
  void *OSQPend( OS_EVENT *pevent, INT16U timeout, INT8U *err);
  
  
/*----------------------------------------------------------------------------
    其他
 *----------------------------------------------------------------------------*/

延时函数:
void  OSTimeDly (INT16U ticks);
ticks: 需要延时的节拍数,而非毫秒数.
调用此函数会将其当前任务挂起,把任务的执行权交由下一个任务.直到延时结束后,本任务进入就绪态.

  
/*----------------------------------------------------------------------------
    ucos 任务框架
 *----------------------------------------------------------------------------*/
  
  
//启动任务
#define START_PRIO    (25)                          //任务优先级(0-62)
#define START_STK_LEN (64)                          //任务栈栈长
__align(8) OS_STK start_stk[START_STK_LEN] = {0};   //任务栈数组
void ucos_start(void *p_arg);                       //ucos任务调度函数
  
int main(int argc, char *argv[])
{
  
  //初始化ucos
  OSInit();
  
  //创建任务
  OSTaskCreate(ucos_start,(void *)0,&start_stk[START_STK_LEN-1],START_PRIO);
  
  //启动ucos
  OSStart();
  
  /*此处以下的代码不会执行*/
  while(1);
  
}

/* 任务创建函数 */
void ucos_start(void *p_arg)
{
  OS_CPU_SysTickInit(); //第一时间启动SysTick时钟
  
  while (1)
  {
    //code...
  }
  
}
  
/*----------------------------------------------------------------------------
    ucos 启动流程
 *----------------------------------------------------------------------------*/
  
//UCOS任务初始化函数
OSInit:
{
  1. 调用UCOS初始化钩子

  2. 初始化杂项变量

  3. 初始化预备链表

  4. 初始化TCB的空链表

  5. 初始化EVENT的空链表

  6. 初始化事件标志结构体(可裁剪)

  7. 初始化内存管理器(可裁剪)

  8. 初始化消息队列结构体(可裁剪)

  9. 创建空闲任务

  10. 创建静态任务(可裁剪)

  11. 初始化时间管理器(可裁剪)

  12. 调用UCOS初始化完成钩子

}


//UCOS任务创建函数
OSTaskCreate:
{
  1. 确保变量在有效范围内(变量检测机制,可裁剪)

  2. 进入临界区

  3. 确保任务不是在中断中创建

  4. 确保这个任务的优先级号没有被占用

  5. 保留当前任务的优先级号,防止被其他任务占用

  6. 初始化任务栈区

  7. 初始化任务控制块

  8. 假如任务控制块初始化成功,则判断OS是否已经运行,若已经在运行则搜寻最高优先级的任务;若任务控制块初始化失败,则释放当前任务申请的优先级号.

  9. 退出临界区

}


//UCOS任务开始函数
OSStart:
{
  1. 确保当前UCOS没有在运行,若在运行则退出

  2. 找到最高优先级任务的优先级数

  3. 指向最高优先级任务并准备运行它

  4. 执行目标特定的代码去启动任务

}












  
  
  
  
  
  
  
  
  
  
  
  